<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>2021年终总结</title>
      <link href="/2022/01/06/2021%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
      <url>/2022/01/06/2021%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="a6ea7d3778454bc2a65692ea5bf36177eb6d9e463773e29e3a588a716da94012">d7eadd0b02eee5183a694f4706bc48020f99b9b6a057dac700abca60f0779a4d8f5446828f96d3ebb0fff3eff1315e38476c5c009eb2bb7fc09cfbc6664ca92d6de0b16b5ca126df013254da1d33ba660b6e4d9cbbc7c30476fbd1e5172982182ba757fd9e9a89f8d53bb3335b62a7f4551f07eb8ac1f2b76773cd1ec681455f8ea29139911c40c87607ce7b0f2b83f22f8ba285e126ceae1469bb8c2781ca416e856978823fc37b0c573e1d6b24cabb2623d58c4a61586e2d3f8c6b9f0c376cd47a1d04984dc5c912745fa0bcfd3fdecb032a18124d6764d2c995bdd77f186a743d7222a8f5661ee2c4d7100345419e75d0be6eb10aa39370f83abc1aac901a2a0c84ab3ea4e4d2cae1077afd2d43883a9111c774f80d436c9f3394364e5699f837b3134db2fe33ebae3fe6de1e203ce919605fda4ce1e45e43c7327712225a7969605e606f6144062be9a4c7975408263fcb00b9d61a31d5243c3b8cc17c575b352fa1a01fd96a9036ee26d4d6978ffbad97d77e5ccfe52a32b30955f88a3a65902617110ae5d77904dd2724733517078eaa7666c2aad9cfb2afd269510fcabf95381cd450ecad29dcb92576e77b01cc9ad0e410d27fcf7f19f217640c84006f7ac1476d3fdef3947fa353bea60bc93bce28d66b70cee06be855ce7c5f29941a09b5e3428381ffd212ad12b6f424c9f497b1e726b78f139628a90d1ac2a67842f1c2ffadec00e5ca4efb8eceebe257e5a22b407a5c4e75b8879c0f5b2439b49f428300a6689f1df858ca9b06358e33d9738d6098367cc4d86628e2b50a1ba2dbe0b09035d26eeb14fa4b1ecc6920d067ef917e71aac15acb8002634905e470db51509e785c7c1e58031f3097398c63cf73cc6f9aae589243441dbace68748b581145998e38a509a91cc550527b0620efebb8ab5607d62d310c4db680d438ab0b21d45ea540aba6c6664a017c13ca4d7531241e6cd4924535ab4e9eadb4fbe42ea6578c178ba9d765bad0e3d25d20d31caa3391d9817db8414de3d0442ef7984b1bbfd1e0c61011bf07ccf33c02289ea606b2fa9af1af4773d1926ffb1a58d70156909feb6a34581c2e037c57fb125ea53735ee4cb9c6197663e1ad5fcdf34e66a5c869ec97ad852489abdf9333dfcd932b65504aab8d9205ccd8fd195f1a53acd78b388a7f9f06be2b60c1ffdeba2124e5f11ab58debb5dfb661c96bbb4e2e1b9eaa709fd37158cb3c71b027e2c193a6c8c8a21602a903de0d2cccb54f966218f3535d88c779d33c9e98060161ca724d66fa30784708f3e1e4e1687f2ded0e6d16fa887db68d734839fc726e6e4d3ffbb9889e84a9ecd188fae27979b462915dc1c0b657f8bccf4e2a7c72afceb27f2e333d2f63f3162dcb7ed83e78184791914444ff719089efbea996aff36487282d6cd6e50561f4306baa8986a6a2f6fa353f397a5dc705b047e869aa30e48fa47900c035e7039a0b9a70c7bafd7bf77d1c5ef7e70520fdb7ad4f699be1cdf23e24d0d71f2dc23f3b7d64a66d250cdf59df48501a6b35eab8b83c1b27672133c4187528d08c7f5ddb0b755b3560c171060a689562c3eebb982dc2a923fb65dd2e64819b8376732bdb7782e4906a10d9a53b18ab6f76a876e07998fafbb87f820350443bf1356d950933ed0e28fc2f98af65a00f4b98f85c34f528c2fff1d12ad441f6a3adab0dcb7dd351f19ca097ba0f81046cabe069f87153f5b97ffb3785122c7ffb9c52e402ec196aaabdf6468d1cf04dee3e9a69ea0c1bbbf806fa5d09a12b684b188d41a2f2695ba60ba7a4b670869ea723f635dffbb38c6af098ed9ea9c5e9ee98cfe896c26b0dc0e0ed6d656cfdd77bcfeda6d984bc9a8e744a2a05f801ae658ca645cdae736977927728da6cdcadd8404ce4e937e73e2c568d72edce3dec6b25dce9faa306830afec053738b01fd7bcf916f7dee662eb0e1607e33e06f51ace1b464e2642a30821d22ef5cf25d64ec4860c94d63eda4930c2b8f81febcd809ec5f687e0c6c5dfb722388062687b96acea58eca0684c3730e271aa02afb40b93e82de33df645c2265d6d854b7a7805564b4510c316825e718e88d6dbde9689693870de1a9bc032e9c497e0c3039d24b7a3fcb19f72eb261f8f3f8e1f2fbf69741a783abcdd14f47beb174f08f4aaef49f8fde51d8b11ca8e6feae3c5186ad1e021871d7958f320050af3f744b3a162b42d2a47e21bae1a7d5efc29f11a335738dcb572a3764692f2d15ce19cbfea680abdfbce7fde8a91e852578e8ff09364151965fa9f68148c12879aa4e88b5886bad92c31420c6e9fab7d111b55c6729c456b56850eda19a07bb14598803d631ccd0d1b15c0cdd000f78b7600772661286efc074a5f84c8c26bbca738a7c6af4c63a18cdea1fe5d6c7ffee7ea4af5f49f1968b2b3753e48eea9b6d0b2944b21e2d8c39bb230c4f1f634f716becfbce9ce4f922ff13b521e8cc29a5863d9415c501688d2e1a068354da042d46528e70fddc82be7274c47445980440753141e7987def91341ba4f71a2d1371eeeceb56f8f455ec240fdff7d89a319cc2c3d1c4fb9a1ff03f9745553d880265d634aa6e64673890665688a10bd1fc3597105779a7563f280ed5f080cdc46efbfd8a53edc674930867ff187bfcd0d620436539</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 年终总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS Vision 框架初探</title>
      <link href="/2021/10/18/iOS-Vision-%E6%A1%86%E6%9E%B6%E5%88%9D%E6%8E%A2/"/>
      <url>/2021/10/18/iOS-Vision-%E6%A1%86%E6%9E%B6%E5%88%9D%E6%8E%A2/</url>
      
        <content type="html"><![CDATA[<p>iOS Vision 框架</p><span id="more"></span><h1 id="iOSVisionDemo"><a href="#iOSVisionDemo" class="headerlink" title="iOSVisionDemo"></a>iOSVisionDemo</h1><p>iOS Vision 框架</p><h5 id="Live-Text"><a href="#Live-Text" class="headerlink" title="Live Text"></a><strong>Live Text</strong></h5><p>iOS15 当中的 Live Text 功能目前只在 相册, 相机 APP 当中提供, 并没有发现开发可以使用的 API。</p><h5 id="Vision"><a href="#Vision" class="headerlink" title="Vision"></a><strong>Vision</strong></h5><p>2017年 iOS11 开始支持的识别框架。</p><p>应用计算机视觉算法对输入图像和视频执行各种任务。</p><p>视觉框架执行人脸和人脸地标检测、文本检测、条形码识别、图像注册和一般特征跟踪。Vision还允许将自定义核心ML模型用于分类或对象检测等任务。</p><h5 id="Demo-相关效果"><a href="#Demo-相关效果" class="headerlink" title="Demo 相关效果"></a><strong>Demo 相关效果</strong></h5><p>原始图片</p><img src="https://i.loli.net/2021/10/15/BDYET3js2cWf81J.png" alt="image.png" style="zoom: 50%;" /><h5 id="Vision-识别效果"><a href="#Vision-识别效果" class="headerlink" title="Vision 识别效果"></a><strong>Vision 识别效果</strong></h5><p>一.  识别到 character 级别<br><img src="https://i.loli.net/2021/10/15/wNzpqlgJUZsrE5B.png" alt="image.png" style="zoom: 20%;" /></p><p>二. 识别到 words 级别<br><img src="https://i.loli.net/2021/10/15/4QGcYwLUEPeWnkb.png" alt="image.png" style="zoom:20%;" /></p><p>三. iOS13 之后 Vision 支持 VNRecognizeTextRequest 文字识别<br><img src="https://i.loli.net/2021/10/15/Ne1zCWEoAu4ctlS.png" alt="image.png" style="zoom:20%;" /></p><p>识别结果</p><p>“Dropbox”</p><p>“最近使用”</p><p>“隔空投送”</p><p>“’ 应用程序”</p><p>“日桌面”</p><p>5</p><p>“—- 识别时长：593.3990478515625 毫秒”</p><h5 id="相关特点"><a href="#相关特点" class="headerlink" title="相关特点:"></a><strong>相关特点:</strong></h5><ol><li> API 1 仅能识别是否有文字. 不能识别出文字到底是什么内容</li><li> 对中文识别结果不友好</li><li> 首次识别 200~600 ms 之间, 取决于图片本身的大小</li><li> 第二次识别时间很短, 猜测是系统做了相关缓存</li><li> 支持的语言</li></ol><p>supportLanguage : [&quot;en-US&quot;, &quot;fr-FR&quot;, &quot;it-IT&quot;, &quot;de-DE&quot;, &quot;es-ES&quot;, &quot;pt-BR&quot;, &quot;zh-Hans&quot;, &quot;zh-Hant&quot;]</p><h5 id="结论"><a href="#结论" class="headerlink" title="结论"></a><strong>结论</strong></h5><p>Vision 可以做图片上是否包含文字的判断功能, 和有限的文字内容识别功能</p><blockquote><p>详见 <a href="https://github.com/rensss/iOSVisionDemo">Demo</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vision </tag>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS 获取 Exif 信息相关</title>
      <link href="/2021/10/12/iOS-%E8%8E%B7%E5%8F%96-Exif-%E4%BF%A1%E6%81%AF%E7%9B%B8%E5%85%B3/"/>
      <url>/2021/10/12/iOS-%E8%8E%B7%E5%8F%96-Exif-%E4%BF%A1%E6%81%AF%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<p>关于获取图片文件的 Exif 信息的 Demo</p><span id="more"></span><h1 id="ExifDemo"><a href="#ExifDemo" class="headerlink" title="ExifDemo"></a>ExifDemo</h1><p>iOS 获取 Exif 信息的 Demo</p><h5 id="EXIF信息"><a href="#EXIF信息" class="headerlink" title="EXIF信息"></a>EXIF信息</h5><p>是可交换图像文件的缩写，是专门为数码相机的照片设定的，可以记录数码照片的属性信息和拍摄数据。EXIF可以附加于JPEG、TIFF、RIFF等文件之中，为其增加有关数码相机拍摄信息的内容和索引图或图像处理软件的版本信息。</p><h5 id="EXIF-以下为可能包含的信息"><a href="#EXIF-以下为可能包含的信息" class="headerlink" title="EXIF 以下为可能包含的信息:"></a>EXIF 以下为可能包含的信息:</h5><table><thead><tr><th><strong>项目</strong></th><th><strong>资讯（举例）</strong></th></tr></thead><tbody><tr><td>制造厂商</td><td>Canon</td></tr><tr><td>相机型号</td><td>Canon EOS-1Ds Mark III</td></tr><tr><td>影像方向</td><td>正常（upper-left）</td></tr><tr><td>影像解析度 X</td><td>300</td></tr><tr><td>影像解析度 Y</td><td>300</td></tr><tr><td>解析度单位</td><td>dpi</td></tr><tr><td>软件</td><td>Adobe Photoshop CS Macintosh</td></tr><tr><td>最后异动时间</td><td>2005:10:06 12:53:19</td></tr><tr><td>YCbCrPositioning</td><td>2</td></tr><tr><td>曝光时间</td><td>0.00800 (1/125) sec</td></tr><tr><td>光圈值</td><td>F22</td></tr><tr><td>拍摄模式</td><td>光圈优先</td></tr><tr><td>ISO感光值</td><td>100</td></tr><tr><td>Exif资讯版本</td><td>30,32,32,31</td></tr><tr><td>影像拍摄时间</td><td>2005:09:25 15:00:18</td></tr><tr><td>影像存入时间</td><td>2005:09:25 15:00:18</td></tr><tr><td>曝光补偿（EV+-）</td><td>0</td></tr><tr><td>测光模式</td><td>点测光（Spot）</td></tr><tr><td>闪光灯</td><td>关闭</td></tr><tr><td>镜头实体焦长</td><td>12 mm</td></tr><tr><td>Flashpix版本</td><td>30,31,30,30</td></tr><tr><td>影像色域空间</td><td>sRGB</td></tr><tr><td>影像尺寸X</td><td>5616 pixel</td></tr><tr><td>影像尺寸Y</td><td>3744 pixel</td></tr></tbody></table><p>在 iOS 当中, 使用 UIImagePickerController 选择单张图片的方法获取的 image 并非是原始图片, 所以不包含原始的 Exif 信息</p><h5 id="UIImagePickerController-解析到的-Exif-信息如下"><a href="#UIImagePickerController-解析到的-Exif-信息如下" class="headerlink" title="UIImagePickerController 解析到的 Exif 信息如下:"></a>UIImagePickerController 解析到的 Exif 信息如下:</h5><pre><code>[&#123;TIFF&#125;: &#123;    Orientation = 6;    ResolutionUnit = 2;    XResolution = 72;    YResolution = 72;&#125;, &#123;Exif&#125;: &#123;    ColorSpace = 1;    ComponentsConfiguration =     (        1,        2,        3,        0    );    ExifVersion =     (        2,        2,        1    );    FlashPixVersion =     (        1,        0    );    PixelXDimension = 4032;    PixelYDimension = 3024;    SceneCaptureType = 0;&#125;, PixelWidth: 4032, PixelHeight: 3024, &#123;JFIF&#125;: &#123;    DensityUnit = 1;    JFIFVersion =     (        1,        0,        2    );    XDensity = 72;    YDensity = 72;&#125;, ProfileName: Display P3, DPIWidth: 72, DPIHeight: 72, ColorModel: RGB, Orientation: 6, Depth: 8]</code></pre><p>经过调研发现, 使用 PHImageManager 的 requestImageDataAndOrientation 方法获取到的 imagedata 包含原始的信息</p><h5 id="PHImageManager-获取-asset-拿到原始-data-后经过解析可以得到如下信息"><a href="#PHImageManager-获取-asset-拿到原始-data-后经过解析可以得到如下信息" class="headerlink" title="PHImageManager 获取 asset 拿到原始 data 后经过解析可以得到如下信息:"></a>PHImageManager 获取 asset 拿到原始 data 后经过解析可以得到如下信息:</h5><pre><code>[&#123;TIFF&#125;: &#123;    DateTime = &quot;2021:10:11 11:09:47&quot;;    HostComputer = &quot;iPhone XS Max&quot;;    Make = Apple;    Model = &quot;iPhone XS Max&quot;;    Orientation = 6;    ResolutionUnit = 2;    Software = &quot;15.0.1&quot;;    TileLength = 512;    TileWidth = 512;    XResolution = 72;    YResolution = 72;&#125;, Orientation: 6, PixelWidth: 4032, PixelHeight: 3024, &#123;Exif&#125;: &#123;    ApertureValue = &quot;1.69599381283836&quot;;    BrightnessValue = &quot;6.159757029988956&quot;;    ColorSpace = 65535;    CompositeImage = 2;    DateTimeDigitized = &quot;2021:10:11 11:09:47&quot;;    DateTimeOriginal = &quot;2021:10:11 11:09:47&quot;;    ExifVersion =     (        2,        3,        2    );    ExposureBiasValue = 0;    ExposureMode = 0;    ExposureProgram = 2;    ExposureTime = &quot;0.00909090909090909&quot;;    FNumber = &quot;1.8&quot;;    Flash = 16;    FocalLenIn35mmFilm = 26;    FocalLength = &quot;4.25&quot;;    ISOSpeedRatings =     (        25    );    LensMake = Apple;    LensModel = &quot;iPhone XS Max back dual camera 4.25mm f/1.8&quot;;    LensSpecification =     (        &quot;4.25&quot;,        6,        &quot;1.8&quot;,        &quot;2.4&quot;    );    MeteringMode = 5;    OffsetTime = &quot;+08:00&quot;;    OffsetTimeDigitized = &quot;+08:00&quot;;    OffsetTimeOriginal = &quot;+08:00&quot;;    PixelXDimension = 4032;    PixelYDimension = 3024;    SceneType = 1;    SensingMethod = 2;    ShutterSpeedValue = &quot;6.786114009295267&quot;;    SubjectArea =     (        2013,        1511,        2217,        1330    );    SubsecTimeDigitized = 440;    SubsecTimeOriginal = 440;    WhiteBalance = 0;&#125;, &#123;GPS&#125;: &#123;    Altitude = &quot;5111.43158627087198&quot;;    AltitudeRef = 0;    DestBearing = &quot;3111.85987089833244&quot;;    DestBearingRef = T;    HPositioningError = 35;    ImgDirection = &quot;3111.85987089833244&quot;;    ImgDirectionRef = T;    Latitude = &quot;4111.02616383333334&quot;;    LatitudeRef = N;    Longitude = &quot;111111.41185&quot;;    LongitudeRef = E;    Speed = 0;    SpeedRef = K;&#125;, PrimaryImage: 1, ProfileName: Display P3, DPIWidth: 72, DPIHeight: 72, ColorModel: RGB, &#123;MakerApple&#125;: &#123;    1 = 14;    12 =     (        &quot;0.7695312&quot;,        &quot;1.242188&quot;    );    13 = 5;    14 = 0;    16 = 1;    17 = &quot;07250F0C-D055-4E2C-9290-7A002339A7F4&quot;;    2 = &#123;length = 512, bytes = 0x63006a00 6b006e00 74007f00 9300a800 ... fb007500 4e005100 &#125;;    20 = 10;    23 = 13639680;    25 = 2;    26 = q900n;    3 =     &#123;        epoch = 0;        flags = 1;        timescale = 1000000000;        value = 190422196502791;    &#125;;    31 = 0;    32 = &quot;50778780-F3AB-48F9-8C74-D070CC6A633F&quot;;    33 = 0;    35 =     (        15,        268435608    );    37 = 394;    38 = 3;    39 = &quot;47.02333&quot;;    4 = 1;    40 = 1;    43 = &quot;06DFDAB5-59F3-47D4-AC2F-04FAFA9118F2&quot;;    45 = 4898;    46 = 1;    47 = 162;    5 = 184;    54 = 5167;    55 = 4;    59 = 0;    6 = 191;    60 = 4;    65 = 0;    7 = 1;    74 = 2;    8 =     (        &quot;0.0132227&quot;,        &quot;-0.3723191&quot;,        &quot;-0.9368563&quot;    );&#125;, Depth: 8]</code></pre><p>具体到每个字段对应的信息还需要继续查找和调研</p><p>详细内容见 <a href="https://github.com/rensss/ExifDemo">Demo</a></p><blockquote><p><a href="https://developer.apple.com/documentation/imageio/cgimageproperties">Apple</a> 对于 CGImageProperties 信息的文档</p><p><a href="https://developer.apple.com/documentation/imageio/cgimageproperties/exif_dictionary_keys">Apple</a> 对于 Exif 信息的文档</p><p><a href="https://photoinvestigator.co/blog/the-mystery-of-maker-apple-metadata/">Maker Apple</a> 字段的相关信息的猜测</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Exif </tag>
            
            <tag> PHImageManager </tag>
            
            <tag> CGImageProperties </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>相似图片技术调研</title>
      <link href="/2021/06/28/%E7%9B%B8%E4%BC%BC%E5%9B%BE%E7%89%87%E6%8A%80%E6%9C%AF%E8%B0%83%E7%A0%94/"/>
      <url>/2021/06/28/%E7%9B%B8%E4%BC%BC%E5%9B%BE%E7%89%87%E6%8A%80%E6%9C%AF%E8%B0%83%E7%A0%94/</url>
      
        <content type="html"><![CDATA[<p>最近研究相似图片的方案调研</p><span id="more"></span><h4 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h4><p><img src="https://i.loli.net/2021/06/28/NwQljgyZUIKVD96.png" alt="相似图片-技术路线图.png"></p><h4 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h4><p><img src="https://i.loli.net/2021/06/28/VfonLwdjr3FkRD7.png" alt="相似图片-技术路线图-大纲.png"></p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 相似图片 </tag>
            
            <tag> 哈希化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git fork 上游仓库</title>
      <link href="/2020/06/08/Git-fork-%E4%B8%8A%E6%B8%B8%E4%BB%93%E5%BA%93/"/>
      <url>/2020/06/08/Git-fork-%E4%B8%8A%E6%B8%B8%E4%BB%93%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<p>GitHub上fork项目后怎么跟上游仓库保持更新。</p><span id="more"></span><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>在GitHub(<del>大型同性交友网站</del>)上我们可以找到大量有趣、有用的Repository,有的时候我们会使用fork工能,但是有时候你想让fork下的仓库跟上游仓库保持更新，那么就需要一些操作。</p><h4 id="详细步骤"><a href="#详细步骤" class="headerlink" title="详细步骤"></a>详细步骤</h4><h5 id="查看仓库状态"><a href="#查看仓库状态" class="headerlink" title="查看仓库状态"></a>查看仓库状态</h5><p>   首先<code>cd</code>到项目目录</p><pre><code>git remote -v # 您的fork的当前配置的远程仓库。</code></pre><p>   如下图所示，即没有设置上游仓库<br>   <img src="https://i.loli.net/2020/06/08/aNLuqkFnpeK3lyR.png" alt="remote -v.png"></p><h5 id="设置上游仓库"><a href="#设置上游仓库" class="headerlink" title="设置上游仓库"></a>设置上游仓库</h5><pre><code>git remote add upstream # https.gitxxx  指定上游仓库</code></pre><p>   重复1步骤查看仓库状态<br>   结果如下<br>   <img src="https://i.loli.net/2020/06/08/GUqIVoDbAzmrPJN.png" alt="remote add upstream.png"></p><h5 id="抓取上游跟新到本地"><a href="#抓取上游跟新到本地" class="headerlink" title="抓取上游跟新到本地"></a>抓取上游跟新到本地</h5><pre><code>git fetch upstream # 抓取上游仓库的更新到本地</code></pre><h5 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h5><p>   列出分支列表</p><pre><code>git branch # 列出当前有多少分支  按q退出编辑模式</code></pre><p>   切换分支</p><pre><code>git checkout master # 切换到 master 主分支</code></pre><h5 id="合并上游更新"><a href="#合并上游更新" class="headerlink" title="合并上游更新"></a>合并上游更新</h5><pre><code>git merge upstream/master # 合并上游更新</code></pre><h5 id="推送合并后的更新"><a href="#推送合并后的更新" class="headerlink" title="推送合并后的更新"></a>推送合并后的更新</h5><pre><code>git push origin master # 推送合并后的更新</code></pre><h4 id="END"><a href="#END" class="headerlink" title="END"></a>END</h4><hr><blockquote><p>ps </p><pre><code># Git 常用命令集git clone git://github.com/limbopro/Script.git # 检出仓库git remote -v # 查看远程仓库 刚刚已经用过了 git remote add [name] [url] # 添加远程仓库 刚刚已经用过了 git remote rm [name] # 删除远程仓库git remote set-url --push [name] [newUrl] # 修改远程仓库git pull [remoteName] [localBranchName] # 拉取远程仓库 与fetch 有所区别 git push [remoteName] [localBranchName] # 推送远程仓库git branch # 查看本地分支 一般默认为 master git branch -r # 查看远程分支git branch [name] # 创建本地分支 注意新分支创建后不会自动切换为当前分支 git checkout [name] # 切换分支git checkout -b [name] # 创建新分支并立即切换到新分支git branch -d [name] # 删除分支 -d选项只能删除已经参与了合并的分支，对于未有合并的分支是无法删除的。如果想强制删除一个分支，可以使用-D选项git merge [name] # 合并分支 将名称为[name]的分支与当前分支合并git status # 查看当前状态 同步上游仓库更新时会常用到git commit # 提交 合并更新后，提交到远程仓库会用到git branch -a # 查看所有的分支git branch -r # 查看远程所有分支# 查看、添加、提交、删除、找回，重置修改文件git help &lt;command&gt; # 显示command的helpgit show # 显示某次提交的内容 git show $idgit co -- &lt;file&gt; # 抛弃工作区修改git co . # 抛弃工作区修改git add &lt;file&gt; # 将工作文件修改提交到本地暂存区git add . # 将所有修改过的工作文件提交暂存区git rm &lt;file&gt; # 从版本库中删除文件git rm &lt;file&gt; --cached # 从版本库中删除文件，但不删除文件git reset &lt;file&gt; # 从暂存区恢复到工作文件git reset -- . # 从暂存区恢复到工作文件git reset --hard # 恢复最近一次提交过的状态，即放弃上次提交后的所有本次修改git ci --amend # 修改最后一次提交记录git revert &lt;$id&gt; # 恢复某次提交的状态，恢复动作本身也创建次提交对象git revert HEAD # 恢复最后一次提交的状态# 查看文件diffgit diff &lt;file&gt; # 比较当前文件和暂存区文件差异 git diffgit diff &lt;id1&gt; &lt;id2&gt; # 比较两次提交之间的差异</code></pre></blockquote>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GitHub </tag>
            
            <tag> git </tag>
            
            <tag> fork </tag>
            
            <tag> upstream </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Quantumult X 体验</title>
      <link href="/2020/06/08/Quantumult-X-%E4%BD%93%E9%AA%8C/"/>
      <url>/2020/06/08/Quantumult-X-%E4%BD%93%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="987197f69c32e735d75f73484eee281b5f5786d14ea4a56eab33fc9905cd6d63">849b3e974761b4206f466fddb895d102775f4af812f73dc44cf58bf8d32ec666487aec3492518b77c05dc8d2c325251ae26157ace5aba5894ce80f5b78ad7dbbdee68ff68725a20b8338289576071eb24b5ad430721561390887cd3a3d359596106991b6fd41a33bc9533a83718e9139525ede1ee47c25df9831898c7daf26f07cdec4227e57a392cc69388de8c872569ee7f47e5ff3ec9aed16c2d1b71140e858df9dd8730947d6cc2811abbea35050c0242dd3fc093d62aa5762adae25b901e4c6893062fdf21067e600c6611b36812db2e044b69b7a0ab47379928798f8a0d1c4a6333fe4640842d879400eac4951ad2685c1f4b8773e92d771a31aae4ac602b4d1899162487d57c3e15e25757b4b90ea3323ed80b710ca6b4dd25c854a0afde75d9890aa8ebdc6a4d6dc93a829349a5cfb580a0b7de4f1bf8e99164c45217a0cb057088cc30a57ec7b640b5f2f9527cfec5d1fda68a253f797534705b20e28d91407d4491925e83dbcfca99791257ee75764e5887ee376e9ab3ce3fcdcda738a26b462c86e94c2f2943a1fb54ba065e7c123b47b7087150780272512be0e08f0607f0364858b67f3ac9dc39ecea5260147b99b380f51f34df644728d32716d6702a55aeee057883a945a08b1a1b86a047856c069d35f4064318594f4e3367f0180409e26d559afcb46fd38af694b90a649b1853ffec6b4cef2c3c760fccf73ed7d640bafa221dbc3b5ec4be3293d581cfcce926c35b5045173c91c2a3d63a89b277c6a3b05eaa6aabc9178eb20e26d9542e73b3d199af5fb610106392f3bc9f7f209b1ea0f2b2450b61a0b7ca166eafdc3e2724082759666025119bbc85e6202a00083b7c02065310eb3767506cf360cfc00edfda78bd3d124f75362ce3b4e51e68d83568df8eea60542d26907f28ac9a063e490c5294712b8b83b1485061ba2cd5b387c6ceb22f23a89d8fa0672cdc20b1510de7131955c83c4900f83cfe322bd5eb17b0487823446dc1aa4e2b34295f1403cecd69f1edd49bc77373f0cc6665fa5905d6053eea6643a99cba5fc2cd5012ef9846e4c656e6cbf7702bb6eb04c31f00276502bfd1ef4b0dc927a67e77e72c3f112e164e5d4a0c2701c73d6bd4c39f6b2c884f3630112346eab61816276d0ec48fbac82048238820d289f4bb3421b7742ed2115d1bdc43bce5dd6f0cbebd59195df7031b2fcb0f02e93ea592a1c934f26495410103bcda25f3d6cb9ad73d995d109e218ffb8ed736f26476dbf2528a4c14794ed0c3d069680a4ebe63713fedd48375a68aa0e958d90279e1d654ee02a70cea2641e0e6ff745c6bd8f72fa883e2c8ead1e94283f21e02604ba1fed323038d0299cdcdf1c0a08e2937654713e4ff2d57d73d164381f57b13451ab798390d7bf147f774c6e71bd69a34df4135056e4c3be3d79ee0a5b9c76b19cf2df0c8e014b3466d6da3edc12e531fe2a82e19430b9952fe5c47dd1885024f1404264b0cdebdb433e9c1519d4a8ef8501a878afb032d69aaaae22530fcb297bd255299849c980e80176e5efd5ee88263f8158f0e5e717c7a4dccdd8cd85dc2521dd043815bcd6a064b5b7694093c530e15d980611cea9194ddec1ccc0a5d775d6d9f432855417b6fed649650514316b451d222e382b675c8f546a752a2b809fab6ed8a6aa3c767df8b039fed422bf5248e13e67e4fb5f6c13682d28dea26e8d4338fdbca1f011a66adbb86bdbb5eb70cf156dcdf05f3cba48d464d0113d8cd5af7bb6157ccfb5bf26244823b87d486b4bc0a8726f376ee00602fe00ee1ee58d47af10d81cd64119ef77c53df8e91cdc00e556f754d56b92064c092ae4b950302139a6f2cb5afe9f9eb3a367269ac72974977a7762cd690c5669e65bf39f6b8be03d1d1345eddeaa7d06d92719064f4fb7d4414587afeb0eb9f06d1848a054c247f7de8f496ad224e8ed99501abb5c6933a46950e1da376da8d969a1735b14208bd624f6ac8f7c418b587191bfc7f05a4b2784adaf79bb56b7824a42e097fcdbd3af3990235f10fe2a4e56d3171fa44e94692420bcbb15d90aaa95b2043a8f3e6e6824766bf0b53e84174216d2eb2dc09983fcb9966f138341e2d7cc3ea96badf8b3f632428cc68a65e8b329ea74cb15b1ba972b67a78a69caf574d56df0e91cf6ab3ac329d5ddb06a2614d833aac5ef176dd75cfa87d6fc94164ed5241ac18b96a7d5059b6164569bfa604f4ce153dfb7d0fd52b5028c8becc6075a77ff9ad18180d8c5c79fdffc6f3d5deff4f7306466760455311512d6d29e3698de54c8db4ccf4829fd68ebefb6964766dfdf0c5c573b481d4166d058dd944cd5a1e14ceda9940303763646a0858b6c2c12137d8ebe7798df146a191dc8ae062edb8b417f76cd4ee616ba1e6916539a956bd16ff08f0e94c5839db0fd25a4cc0419bfce78be35f2c4a9053cc2aa5bfe79fbb1261da9a51bc714bab3fdff9fd72b9d752eb859a177fd0d391530a50487737d364cb632ec9f76a92d8e3a46c7eafd3b6f6b6a5f71eedf4946b2dec67a09907e2734fd5466163b9ddd7fd69154c1a66e62e5bbb61cf0079ae8c1094405a3d173fc7dad03ebf524ca61a2aca9f2dda1277d54a368772ee87646ab4b7bdecb7bc608eea511c810c55bb07da33558fa6da363b39dc4b0006290e1c14692a4c98cc2e9341ad4c599816d3f8f8b7f9433da6d57f0b98f4e96f16b953eee281c8af03108a9f94b08f5d6427d21f94ec13541bb9a90127f51d88f42626580074ad1d1fd2af24bc67b92c11e851933bde498d445b489b69f611ecba5008a325937f7066efbc5217f01c7d67a6da974a405a4ed83e186e57562f9bb4d77d33243f2d8c9bf66752eabcc5f64756752eaa657c4399fe1c43f0af7ecc1b7d52c3293d67130443c745d3aba1dbbc73b23d8e66ce9d2261f3a3f396e8c8200fa335ac3dbc1ea6995ab196a2e00c404bd5318d8824821a84d15fe0ac5ad3ded810cf416ee158ffed45ccbe891759f619488ee7fc6543f60ab6971ea3561f626d5a904ef51bda69633a29255a9e7eb84b9788b59ca1e803ab25d013f95c844d7e2b0dd75ce0cde58a2eb2dc0cb788856d8279888c3835811eadf62ce48bd2ac617e5741b806ecdbb179dea04bbe49b75358ee69e5ca9344c7bd4658a3b35a7c74f12ae7502c762a79e2240170e8affb52ab2e3b0aa94c7819e68163b886a3f8bed12a6126ade3f481a4513dc1ee93ca4ece41f84aedf27c2c89b9e2aa552f64bf60fea9efe78c234cc4bced188be30c8c6f7156762fc9b00bd7b48b711d1787096fdb7dbf6799d21aa1d0c96ce9c53a41e94a6aa06bc767e162218d23c182a517f39aecac5f753a4334c231b066efba1eaf0544002db4186a7237b0374d35cc1a2317fe335e865771cb6290ddd8eacc93791e4a665004be0334c14a89894e9d70b3d39d581ab665b3e5b124d93a0d92dd98eb97fcac4215cb91455a6eebdee8724efe4957749c3b08f651936eeec5b67067499a4ca9bd23110068170e1bedecc672d07af1bb9cef862d8dfec1e17f82dbfdc165a2a4b7d1672732947644c779ba4134d7cf13a0e5192645e40cf211dd8c7c01bfed4af4079544c795aa33a62e937e76cf59a83447593369e6b36b9359ec4affc6f644970b8702e05ea17233d53ef4ad8cbaeebd9d85c37cb33f4838cb72cb5b93c59626fd65474a7264a55f3f2cc5a2cb6a7c0b581dbcc2253f546aee18571187ee8a0ab180fa22c974a722667395041e2ea14846d48a3b296e16e85c62a63f057fd34e12eb803a0cba64a40e8bc8056aefb8f6671812b66e3ad9f044f0bafc96cde211cfb55fac9e4485d45bf54af91d5b8f693ddd78d926ee50a8e82d151028a6536717c87422d18d64b8fb1d8e6f3c47bd3c05ef14657b72faaf9c308ae37df173bd99126e9b4edf249ba4f6f004c6ede703fad745cab9d7e8d8f6c449e4958582701a5777dfd469ca6c24574b5a0dd3de98c2c13ce3977f5f5d6958e9b907fd0ee40a199b58529b3344cc91f34daf077151b2e77cdeaf2cd21659068df7134945086933a44b84bc983c088a5853795e5f7bc1154a2809ce22a409ba0451fbbd0376ba3689a2b276e3e21be8d00b05dbfc97ae300062bf390a5d4f4aee9dc30edfe034c9881a672a6331862af100cd06843858b9840cf1c88b1ee47f75b38a3aa08ef1c34f81186e361f7dbc3b8060f4b9b5e48f84ec8776862b67f08343b5329e0b227ff9f7dcb773adf8bd0345a38ee9e508d97e92b6beae021e7cafa27f3ecaeb97a4315fb40878b3176da9d906beb5bc49e925301832eefd46169b6a8015a1e9688969e04</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>测试加密</title>
      <link href="/2019/10/17/%E6%B5%8B%E8%AF%95%E5%8A%A0%E5%AF%86/"/>
      <url>/2019/10/17/%E6%B5%8B%E8%AF%95%E5%8A%A0%E5%AF%86/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="63d22b3c403704c5d740f63bbba0701f3b585dc3d13402dce0c25e32572b6090">90b802059200f1da98db072b6ecfd0773b1fb566e0ac1faf0e3621a337f25a9fe9c82d4561f8b58cc252f47d136d3d694d18f24c8edc401f3bfadcc1c05c6b241e9d1cb44f849629dfffed67687a633a1af75e475909bbf7796f85b4bd2e7d37d898da18ecbb1d1c46a9971e2134942396053ba168cf46e287d64d94fb5d5da94732ac4a791f665289d6894cbc14cd4a8172b4f85c68c85702b03a96c4bde6f695089525d4159a1e3a57624e1718e4ee13636f119d94cc6c71b0228d13416fd570af031b1be6ee5d1b6e178f13543e3c0e099df35c336fb19e11ff8adf3aba5d2a5c7b88af87bf267b3de7d76b85b9605d84b7c14991e77eab2c180b16c9c9176184d3b24890e67f00755a6e5c9f06a0b8e1045b23444ea6bdf3f4e4bdd9b10f</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">You must enter the password to read.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Xcode编译相关</title>
      <link href="/2019/09/27/Xcode%E7%BC%96%E8%AF%91%E7%9B%B8%E5%85%B3/"/>
      <url>/2019/09/27/Xcode%E7%BC%96%E8%AF%91%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<p>有时候Xcode编译很慢……</p><span id="more"></span><h3 id="查看编译时间"><a href="#查看编译时间" class="headerlink" title="查看编译时间"></a>查看编译时间</h3><p>Terminal 输入:</p><pre><code>defaults write com.apple.dt.Xcode ShowBuildOperationDuration YES</code></pre><p>ps:需重启Xcode<br>如下<br><img src="https://i.loli.net/2019/12/09/vrozlcCqZRLtXy9.png" width="100%" height="100%"></p><h3 id="po打印出的对象为空"><a href="#po打印出的对象为空" class="headerlink" title="po打印出的对象为空"></a><code>po</code>打印出的对象为空</h3><h4 id="主target"><a href="#主target" class="headerlink" title="主target"></a>主target</h4><p>有的时候在LLDB试用<code>po</code>命令时可能会出现错误</p><pre><code>error: warning: couldn’t get cmd pointer (xxx NULL): extracting data from value failed Couldn’t materialize: couldn’t get the value of variable now: no location, value may have been optimized out Errored out in Execute, couldn’t PrepareToExecuteJITExpression</code></pre><p>原因是编译选项选择的是快速+优化。<br>相关内容是Xcode中Optimization Level的设置。</p><p>一共有七种选项:</p><ul><li>None[-O0]: 不优化。在这种设置下， 编译器的目标是降低编译消耗，保证调试时输出期望的结果。程序的语句之间是独立的：如果在程序的停在某一行的断点出，我们可以给任何变量赋新值抑或是将程序计数器指向方法中的任何一个语句，并且能得到一个和源码完全一致的运行结果。</li><li>Fast[-O1]: 大函数所需的编译时间和内存消耗都会稍微增加。在这种设置下，编译器会尝试减小代码文件的大小，减少执行时间，但并不执行需要大量编译时间的优化。在苹果的编译器中，在优化过程中，严格别名，块重排和块间的调度都会被默认禁止掉。</li><li>Faster[-O2]: 编译器执行所有不涉及时间空间交换的所有的支持的优化选项。在这种设置下，编译器不会进行循环展开、函数内联或寄存器重命名。和‘Fast[-O1]’项相比，此设置会增加编译时间和生成代码的性能。</li><li>Fastest[-O3]: 在开启‘Fast[-O1]’项支持的所有优化项的同时，开启函数内联和寄存器重命名选项。这个设置有可能会导致二进制文件变大。</li><li>Fastest, Smallest[-Os]: 优化大小。这个设置开启了‘Fast[-O1]’项中的所有不增加代码大小的优化选项，并会进一步的执行可以减小代码大小的优化。</li><li>Fastest, Aggressive Optimizations[-Ofast]: 这个设置开启了“Fastest[-O3]”中的所有优化选项，同时也开启了可能会打破严格编译标准的积极优化，但并不会影响运行良好的代码。</li><li>Smallest, Aggressive Size Optimizations [-Oz]: 与相似-Os，但会进一步减小代码大小，并且可能需要更长的时间才能运行。</li></ul><p>那么想要详细信息就需要改为第一种。<br><img src="https://i.loli.net/2019/12/09/I5YaLAiWFloVJBj.jpg" width="100%" height="100%"></p><h4 id="pod里的Optimization-Level"><a href="#pod里的Optimization-Level" class="headerlink" title="pod里的Optimization Level"></a>pod里的Optimization Level</h4><p>我们在使用pod的时候，每一个pod其实都是一个target，它有自己的Optimization Level。cocoapods默认给每一个pod的Optimization Level设置的是Fastest, Smallest，也就是说执行所有的优化和减少内存占用空间。</p><p>这样我们在开发的时候会有两个问题：一个是debug的时候无法输出pod源码里面的变量值，因为编译器已经给代码做了优化，它无法再记录你的变量值了。</p><p>把所有pod的的Optimization Level设置为None只需在Podfile里加入以下代码即可（其中的”Dev”为你项目的Scheme）:</p><pre><code>post_install do |installer|  installer.pods_project.build_configurations.each do |config|    if config.name.include?(&quot;Dev&quot;)      config.build_settings[&#39;GCC_OPTIMIZATION_LEVEL&#39;] = &#39;0&#39;    end  endend</code></pre><h3 id="设置Xcode编译的线程数"><a href="#设置Xcode编译的线程数" class="headerlink" title="设置Xcode编译的线程数"></a>设置Xcode编译的线程数</h3><pre><code>defaults write xcodebuild PBXNumberOfParallelBuildSubtasks 8defaults write xcodebuild IDEBuildOperationMaxNumberOfConcurrentCompileTasks 8defaults write com.apple.xcode PBXNumberOfParallelBuildSubtasks 8defaults write com.apple.xcode IDEBuildOperationMaxNumberOfConcurrentCompileTasks 8</code></pre><p>Xcode默认使用与CPU核数相同的线程来进行编译，但由于编译过程中的IO操作往往比CPU运算要多，因此适当的提升线程数可以在一定程度上加快编译速度。</p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Xcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Charles使用总结</title>
      <link href="/2019/09/02/Charles%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
      <url>/2019/09/02/Charles%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>mac上使用Charles抓包的使用总结</p><span id="more"></span><h4 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h4><p>软件长这样⬇️<br><img src="http://tva1.sinaimg.cn/large/007X8olVly1g7rtffrhnfj308209eabu.jpg" width="20%" height="100%"><br>别名青花瓷(花瓶?)……</p><hr><p>笔者使用的是汉化版(英语渣……)⬇️<br><img src="http://tva1.sinaimg.cn/large/007X8olVly1g7rtg1spvpj310o0goww5.jpg" width="100%" height="100%"></p><p>首页如下⬇️</p><p><img src="http://tva1.sinaimg.cn/large/007X8olVly1g7rtgieovjj31g40u0ad7.jpg" alt="image.png"></p><hr><h4 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h4><p>好了开始进入正题。<br>现在大部分应用都已经启用https请求了，那么就略过http抓包吧。</p><h5 id="设置根证书"><a href="#设置根证书" class="headerlink" title="设置根证书"></a>设置根证书</h5><p><img src="http://tva1.sinaimg.cn/large/007X8olVly1g7rth6ylm2j30sm0gwdup.jpg" alt="image.png"><br>点击帮助-&gt;SSL设置-&gt;安装Charles Root证书<br>安装后选择证书，双击，修改为 <code>始终信任</code><br><img src="http://tva1.sinaimg.cn/large/007X8olVly1g7rthn3lmtj30u012ltks.jpg" alt="image.png"></p><h5 id="Charles设置代理"><a href="#Charles设置代理" class="headerlink" title="Charles设置代理"></a>Charles设置代理</h5><p>其实默认的设置就可以。<br><img src="http://tva1.sinaimg.cn/large/007X8olVly1g7rti5yc5nj30ww0s2aca.jpg" alt="image.png"></p><h5 id="设置iOS手机证书"><a href="#设置iOS手机证书" class="headerlink" title="设置iOS手机证书"></a>设置iOS手机证书</h5><p>手机与mac连接同一个wifi后，修改代理，设置为mac电脑。<br>之后打开<code>chls.pro/ssl</code>安装证书。<br><img src="http://tva1.sinaimg.cn/large/007X8olVly1g7rtijzdtnj30yg074mzg.jpg" alt="image.png"><br>安装之后需要在 设置-&gt;通用-&gt;关于手机-&gt;证书信任设置 中信任证书。</p><h5 id="设置代理，开始抓包"><a href="#设置代理，开始抓包" class="headerlink" title="设置代理，开始抓包"></a>设置代理，开始抓包</h5><p>之后可以开是抓包了，但是，还是看不到数据。这是因为需要进行SSL设置。<br>在Charles 代理-&gt;SSL代理设置 中添加想要抓包的数据的域名。类似<code>example.com:443</code>。<br>也可以直接设置<code>*:*</code>。表示抓取全部数据。<br><img src="http://tva1.sinaimg.cn/large/007X8olVly1g7rtixq6f0j30ww0noq56.jpg" alt="image.png"></p><h4 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h4><p>之后配合之前分享过的<a href="https://rensss.github.io/2019/08/02/%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93%E7%AF%87/#%E6%8E%A5%E5%8F%A3%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7-Paw">Paw</a>请求工具，就可以愉快的玩耍了！</p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技巧 </tag>
            
            <tag> Mac </tag>
            
            <tag> iPhone </tag>
            
            <tag> 抓包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>技巧总结篇</title>
      <link href="/2019/08/02/%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93%E7%AF%87/"/>
      <url>/2019/08/02/%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<p>开发中可能会遇到的各种技巧。。。</p><span id="more"></span><h2 id="Xcode部分"><a href="#Xcode部分" class="headerlink" title="Xcode部分"></a>Xcode部分</h2><h3 id="Organzier-用户上传的的崩溃日志"><a href="#Organzier-用户上传的的崩溃日志" class="headerlink" title="Organzier 用户上传的的崩溃日志"></a>Organzier 用户上传的的崩溃日志</h3><p>用户上传崩溃日志，可以在Xcode的Organzier里面查看。<br>Xcode-&gt;Windows-&gt;Organizer<br><img src="http://tva1.sinaimg.cn/large/007X8olVly1g7rszghv5xj30jy0i6gze.jpg" width="50%" height="50%"><br><img src="http://tva1.sinaimg.cn/large/007X8olVly1g7rsxgge61j31ie0u0gxi.jpg" alt="crush.png"><br>优点是很详细，很方便。但是，并非所有用户都会上传崩溃信息。所以这个只能作为其他崩溃统计信息的补充。不能当做主力来源。sad。。。</p><h3 id="断点调试Autolayout"><a href="#断点调试Autolayout" class="headerlink" title="断点调试Autolayout"></a>断点调试Autolayout</h3><p>有时候可能会遇到这样的自动布局bug</p><pre><code class="c">2019-08-09 15:29:39.111289+0800 FastClean[18148:888972] [LayoutConstraints] Unable to simultaneously satisfy constraints.    Probably at least one of the constraints in the following list is one you don&#39;t want.     Try this:         (1) look at each constraint and try to figure out which you don&#39;t expect;         (2) find the code that added the unwanted constraint or constraints and fix it. (    &quot;&lt;NSLayoutConstraint:0x60000263a850 H:|-(15)-[UIButton:0x7fd6d5f366f0](LTR)   (active, names: &#39;|&#39;:UIView:0x7fd6d5f36030 )&gt;&quot;,    &quot;&lt;NSLayoutConstraint:0x60000263a620 UIButton:0x7fd6d5f366f0.right == UIView:0x7fd6d5f36030.right - 15   (active)&gt;&quot;,    &quot;&lt;NSLayoutConstraint:0x600002647e80 &#39;UIView-Encapsulated-Layout-Width&#39; UIView:0x7fd6d5f36030.width == 0   (active)&gt;&quot;)Will attempt to recover by breaking constraint &lt;NSLayoutConstraint:0x60000263a620 UIButton:0x7fd6d5f366f0.right == UIView:0x7fd6d5f36030.right - 15   (active)&gt;Make a symbolic breakpoint at UIViewAlertForUnsatisfiableConstraints to catch this in the debugger.The methods in the UIConstraintBasedLayoutDebugging category on UIView listed in &lt;UIKitCore/UIView.h&gt; may also be helpful.</code></pre><p>那么你可以添加一种布局短点，在布局出现问题时可以添加<code>Symbolic breakpoint</code>断点。<br>内容填为<code>UIViewAlertForUnsatisfiableConstraints</code>。<br>如下：<br><img src="http://tva1.sinaimg.cn/large/007X8olVly1g7rt0frh4jj30qg0amqhn.jpg" width="100%" height="30%"><br>然而并没有什么卵用，直接断到线程堆栈上。啥有用的信息都没有…………</p><p>那么应该怎么搞呢，这里有个小技巧。在上面那个断点中添加<code>action</code><br><code>po [[UIWindow keyWindow] _autolayoutTrace]</code><br>如下图：<br><img src="http://tva1.sinaimg.cn/large/007X8olVly1g7rt11vubij30qy0d2nfy.jpg" width="100%" height="30%" /></p><p>会得到类似下图的view层次结构:</p><img src="http://tva1.sinaimg.cn/large/007X8olVly1g7rt1e2szqj30u00xmaqs.jpg" /><p>还是不够直接啊…  那么你可以</p><pre><code>(lldb) e id $myView = (id) 0x7fd6d5d239e0(lldb) e (void)[$myView setBackgroundColor:[UIColor blackColor]]</code></pre><p>那么该元素就会被着色，你就可以看到它了！</p><h2 id="iPhone部分"><a href="#iPhone部分" class="headerlink" title="iPhone部分"></a>iPhone部分</h2><p><a href="https://rensss.github.io/2019/09/02/Charles%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/">Charles使用技巧</a></p><h2 id="Mac软件部分"><a href="#Mac软件部分" class="headerlink" title="Mac软件部分"></a>Mac软件部分</h2><h3 id="接口调试工具-Paw"><a href="#接口调试工具-Paw" class="headerlink" title="接口调试工具 Paw"></a>接口调试工具 Paw</h3><p>长这个样子⬇️<br><img src="http://tva1.sinaimg.cn/large/007X8olVly1g7rt6xebbnj30c60bmjs9.jpg" width="30%" height="30%" /><br>这是一个调试接口用的工具，可以很方便的调试网络请求。</p><p>详情如下⬇️<br><img src="http://tva1.sinaimg.cn/large/007X8olVly1g7rt83vz9wj30yg0osq80.jpg" width="100%" height="100%"></p><p>返回结果解析<br><img src="http://tva1.sinaimg.cn/large/007X8olVly1g7rt8id95ij30u01ev7tz.jpg" width="100%" height="100%"></p><h3 id="Application-Loader"><a href="#Application-Loader" class="headerlink" title="Application Loader"></a>Application Loader</h3><p>上传APP<br>Xcode 11把Application Loader去掉了，使用上很不方便，下面是官方提供的命令:<br><img src="http://tva1.sinaimg.cn/large/007X8olVly1g7rscpm1i4j31680u07ap.jpg" width="100%" height="100%"></p><p>或者像我这样懒的，从Xcode10里面把 Application Loader 抽取出来，hhh<br>放上下载连接(蓝奏云):<br><a href="https://www.lanzous.com/i6ns6ad"><strong>下载</strong></a> 密码:f7qy</p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技巧 </tag>
            
            <tag> Mac </tag>
            
            <tag> iPhone </tag>
            
            <tag> Xcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown语法</title>
      <link href="/2018/05/12/Markdown%E8%AF%AD%E6%B3%95/"/>
      <url>/2018/05/12/Markdown%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>Markdown 常用语法</p><span id="more"></span><h1 id="Markdown-语法"><a href="#Markdown-语法" class="headerlink" title="Markdown 语法"></a>Markdown 语法</h1><h2 id="什么是-Markdown"><a href="#什么是-Markdown" class="headerlink" title="什么是 Markdown"></a>什么是 Markdown</h2><p>Markdown 是一种方便记忆、书写的纯文本标记语言，用户可以使用这些标记符号以最小的输入代价生成极富表现力的文档：譬如您正在阅读的这份文档。它使用简单的符号标记不同的标题，分割不同的段落，<strong>粗体</strong> 或者 <em>斜体</em> 某些文字，更棒的是，它还可以</p><h2 id="1-制作一份待办事宜"><a href="#1-制作一份待办事宜" class="headerlink" title="1. 制作一份待办事宜"></a>1. 制作一份待办事宜</h2><ul><li><input disabled="" type="checkbox"> 支持以 PDF 格式导出文稿</li><li><input disabled="" type="checkbox"> 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率</li><li><input checked="" disabled="" type="checkbox"> 新增 Todo 列表功能</li><li><input checked="" disabled="" type="checkbox"> 修复 LaTex 公式渲染问题</li><li><input checked="" disabled="" type="checkbox"> 新增 LaTex 公式编号功能</li></ul><h2 id="2-书写一个质能守恒公式-LaTeX"><a href="#2-书写一个质能守恒公式-LaTeX" class="headerlink" title="2. 书写一个质能守恒公式[^LaTeX]"></a>2. 书写一个质能守恒公式[^LaTeX]</h2><p>$$E=mc^2$$</p><h2 id="3-高亮一段代码-code"><a href="#3-高亮一段代码-code" class="headerlink" title="3. 高亮一段代码[^code]"></a>3. 高亮一段代码[^code]</h2><pre><code class="python">@requires_authorizationclass SomeClass:    passif __name__ == &#39;__main__&#39;:    # A comment    print &#39;hello world&#39;</code></pre><h2 id="4-高效绘制"><a href="#4-高效绘制" class="headerlink" title="4. 高效绘制"></a>4. 高效绘制</h2><pre><code class="flow">st=&gt;start: Startop=&gt;operation: Your Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op</code></pre><h2 id="5-高效绘制"><a href="#5-高效绘制" class="headerlink" title="5. 高效绘制"></a>5. 高效绘制</h2><pre><code class="seq">Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks!</code></pre><h2 id="6-高效绘制"><a href="#6-高效绘制" class="headerlink" title="6. 高效绘制"></a>6. 高效绘制</h2><pre><code class="gantt">    title 项目开发流程    section 项目确定        需求分析       :a1, 2016-06-22, 3d        可行性报告     :after a1, 5d        概念验证       : 5d    section 项目实施        概要设计      :2016-07-05  , 5d        详细设计      :2016-07-08, 10d        编码          :2016-07-15, 10d        测试          :2016-07-22, 5d    section 发布验收        发布: 2d        验收: 3d</code></pre><h2 id="7-绘制表格"><a href="#7-绘制表格" class="headerlink" title="7. 绘制表格"></a>7. 绘制表格</h2><table><thead><tr><th>项目</th><th align="right">价格</th><th align="center">数量</th></tr></thead><tbody><tr><td>计算机</td><td align="right">$1600</td><td align="center">5</td></tr><tr><td>手机</td><td align="right">$12</td><td align="center">12</td></tr><tr><td>管线</td><td align="right">$1</td><td align="center">234</td></tr></tbody></table><h2 id="8-更详细语法说明"><a href="#8-更详细语法说明" class="headerlink" title="8. 更详细语法说明"></a>8. 更详细语法说明</h2><p>总而言之，不同于其它 <em>所见即所得</em> 的编辑器：你只需使用键盘专注于书写文本内容，就可以生成印刷级的排版格式，省却在键盘和工具栏之间来回切换，调整内容和格式的麻烦。<strong>Markdown 在流畅的书写和印刷级的阅读体验之间找到了平衡。</strong> 目前它已经成为世界上最大的技术分享网站 GitHub 和 技术问答网站 StackOverFlow 的御用书写格式。</p><hr><p>[^LaTeX]: 支持 <strong>LaTeX</strong> 编辑显示支持，例如：$\sum_{i=1}^n a_i=0$， 访问 [MathJax][4] 参考更多使用方法。</p><p>[^code]: 代码高亮功能支持包括 Java, Python, JavaScript 在内的，<strong>四十一</strong>种主流编程语言。</p><blockquote><p>ps:<br>参考链接  <a href="https://www.zybuluo.com/mdeditor#439859">作业部落</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>本地图片加载卡顿</title>
      <link href="/2018/05/12/%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E5%8D%A1%E9%A1%BF/"/>
      <url>/2018/05/12/%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E5%8D%A1%E9%A1%BF/</url>
      
        <content type="html"><![CDATA[<p>当列表中加载太多的高清大图后,流畅度就会大大降低,本文将试图改善这一问题.</p><span id="more"></span><p>#本地大图加载卡顿</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>在项目<a href="https://github.com/rensss/iphone_webServer">iphone_webServer</a>中,网页上传众多大图后,每个图片的显示,占用诸多内存,导致卡顿.</p><blockquote><p>   e.g.<br>   以一张尺寸为900 × 600的图片为例，图片共有像素数：<br>   900 × 600 = 540,000像素(Pixel)。<br>   如果图片是RGB 色彩模式，占用的内存是：<br>   900 × 600 × 3 = 1,620,000 字节(bytes).<br>   后面”× 3”表示每个像素内RGB 颜色的信息需要3字节，也是24比特(bit)。 <br>   也可以说每个像素中 3 RGB值，每一个RGB值需要一个 8 比特，也是一个字节，总计24个比特。</p></blockquote><h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><p>本地文件读取后,生成小图片加载到UIImageView上</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="Objective-C">// 小图宽高CGFloat height = self.height;CGFloat width = img.size.width * height / img.size.height;// 生成小图片CGSize newSize = CGSizeMake(width, height);UIGraphicsBeginImageContextWithOptions(newSize, NO, 0.0);[img drawInRect:CGRectMake(0, 0, newSize.width, newSize.height)];UIImage *smallImg = UIGraphicsGetImageFromCurrentImageContext();UIGraphicsEndImageContext();</code></pre><h2 id="Over"><a href="#Over" class="headerlink" title="Over"></a>Over</h2>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UIImageView </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序</title>
      <link href="/2017/10/23/%E6%8E%92%E5%BA%8F/"/>
      <url>/2017/10/23/%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>iOS 中的几种排序方法.</p><span id="more"></span><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><pre><code>    NSArray *data = [NSArray arrayWithObjects:                     @&quot;12&quot;,@&quot;4&quot;,@&quot;3&quot;,@&quot;10&quot;,@&quot;25&quot;,                     @&quot;17&quot;,@&quot;22&quot;,@&quot;44&quot;,@&quot;1&quot;,@&quot;18&quot;,                     @&quot;35&quot;,@&quot;11&quot;,@&quot;21&quot;,@&quot;16&quot;,@&quot;34&quot;,                     @&quot;63&quot;,@&quot;102&quot;,@&quot;65&quot;,@&quot;37&quot;,@&quot;97&quot;, nil];    NSArray *resaultArr;    // 计算代码运行时间    CFAbsoluteTime startTime = CFAbsoluteTimeGetCurrent();    resaultArr = [self bubbleSort:data];    CFAbsoluteTime linkTime = (CFAbsoluteTimeGetCurrent() - startTime);    NSLog(@&quot;冒泡排序 Linked in %f ms&quot;, linkTime * 1000.0);//    NSLog(@&quot;%@&quot;,resaultArr);        startTime = CFAbsoluteTimeGetCurrent();    resaultArr = [self selectSort:data];    linkTime = (CFAbsoluteTimeGetCurrent() - startTime);    NSLog(@&quot;选择排序 Linked in %f ms&quot;, linkTime * 1000.0);//    NSLog(@&quot;%@&quot;,resaultArr);        startTime = CFAbsoluteTimeGetCurrent();    resaultArr = [self hillSort:data];    linkTime = (CFAbsoluteTimeGetCurrent() - startTime);    NSLog(@&quot;希尔排序 Linked in %f ms&quot;, linkTime * 1000.0);//    NSLog(@&quot;%@&quot;,resaultArr);        startTime = CFAbsoluteTimeGetCurrent();    resaultArr = [self quicksort:data];    linkTime = (CFAbsoluteTimeGetCurrent() - startTime);    NSLog(@&quot;快速排序 Linked in %f ms&quot;, linkTime * 1000.0);//    NSLog(@&quot;%@&quot;,resaultArr);</code></pre><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><pre><code>/** 冒泡排序 @param dataSourceArr 数据源 @return 有序数据 */- (NSArray *)bubbleSort:(NSArray *)dataSourceArr &#123;            NSMutableArray *currentArray = dataSourceArr.mutableCopy;    NSInteger count = dataSourceArr.count;    //外循环控制  多少轮    for (NSInteger i = 0; i &lt; count; i++) &#123;        //内循环比较  j元素 跟 j+1 比较 相邻的元素        for (NSInteger j = 0; j &lt; count - 1 - i; j++) &#123;            if ([currentArray[j] integerValue] &gt; [currentArray[j + 1] integerValue]) &#123;                NSObject *temp = currentArray[j + 1];                currentArray[j + 1] = currentArray[j];                currentArray[j] = temp;            &#125;        &#125;    &#125;        return currentArray.copy;&#125;</code></pre><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><pre><code>/** 选择排序 @param dataSourceArr 数据源 @return 有序数据 */- (NSArray *)selectSort:(NSArray *)dataSourceArr &#123;        NSMutableArray *currentArray = dataSourceArr.mutableCopy;    NSInteger count = dataSourceArr.count;    //外层控制轮数 需要比较多少轮    for (NSInteger i = 0; i &lt; count; i++) &#123;        //每轮跟其它元素比较 选出最大的 交换        for (NSInteger j = i + 1; j &lt; count; j++) &#123;            if ([currentArray[i] integerValue] &gt; [currentArray[j] integerValue]) &#123;                NSObject *temp = currentArray[j];                currentArray[j] = currentArray[i];                currentArray[i] = temp;            &#125;        &#125;    &#125;    return currentArray.copy;&#125;</code></pre><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>示意图</p><p><img src="https://raw.githubusercontent.com/rensss/Sort/master/source/hillSort.gif" alt="Sorting_shellsort_anim.gif"></p><pre><code>/** 希尔排序 @param dataSourceArr 数据源 @return 有序数组 */- (NSArray *)hillSort:(NSArray *)dataSourceArr &#123;        /*     步长的选择是希尔排序的重要部分。只要最终步长为1任何步长序列都可以工作。算法最开始以一定的步长进行排序。然后会继续以一定步长进行排序，最终算法以步长为1进行排序。当步长为1时，算法变为插入排序，这就保证了数据一定会被排序。          已知的最好步长序列是由Sedgewick提出的(1, 5, 19, 41, 109,...)，该序列的项来自 &#123;\displaystyle 9\times 4^&#123;i&#125;-9\times 2^&#123;i&#125;+1&#125; 9\times 4^&#123;i&#125;-9\times 2^&#123;i&#125;+1和 &#123;\displaystyle 2^&#123;i+2&#125;\times (2^&#123;i+2&#125;-3)+1&#125; 2^&#123;&#123;i+2&#125;&#125;\times (2^&#123;&#123;i+2&#125;&#125;-3)+1这两个算式。这项研究也表明“比较在希尔排序中是最主要的操作，而不是交换。”用这样步长序列的希尔排序比插入排序要快，甚至在小数组中比快速排序和堆排序还快，但是在涉及大量数据时希尔排序还是比快速排序慢。     另一个在大数组中表现优异的步长序列是（斐波那契数列除去0和1将剩余的数以黄金分区比的两倍的幂进行运算得到的数列）：(1, 9, 34, 182, 836, 4025, 19001, 90358, 428481, 2034035, 9651787, 45806244, 217378076, 1031612713,…)     */        NSMutableArray *currentArray = dataSourceArr.mutableCopy;    NSInteger gap = currentArray.count / 2;    NSInteger i,j;        while (gap &gt;= 1) &#123;                for (i = gap; i &lt; currentArray.count; i ++) &#123;            NSString *temp = currentArray[i];                        for (j = i - gap; j &gt;= 0 &amp;&amp; [currentArray[j] integerValue] &gt; [temp integerValue]; j -= gap)                currentArray[j + gap] = currentArray[j];                        currentArray[j + gap] = temp;        &#125;        gap = gap / 2;    &#125;        return currentArray.copy;&#125;</code></pre><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>示意图<br><img src="https://raw.githubusercontent.com/rensss/Sort/master/source/quickSort.gif" alt="quickSort"></p><pre><code>/** 快速排序  @param dataSourceArr 数据源 @return 有序数据 */- (NSArray *)quicksort:(NSArray *)dataSourceArr &#123;        NSMutableArray *currentArray = dataSourceArr.mutableCopy;    NSInteger i,j,key;    for (i = 1; i &lt; [currentArray count]; i++) &#123;            key = [currentArray[i] integerValue];            j = i-1;            while ((j &gt;= 0) &amp;&amp; ([currentArray[j] integerValue] &gt; key)) &#123;                    currentArray[j+1] = currentArray[j];                    j--;            &#125;            currentArray[j+1] = @(key);    &#125;        return currentArray.copy;&#125;</code></pre><h3 id="函数用时"><a href="#函数用时" class="headerlink" title="函数用时"></a>函数用时</h3><p><img src="https://raw.githubusercontent.com/rensss/Sort/master/source/result.png" alt="排序结果.png"></p><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>希尔排序比冒泡排序和选择排序要快很多! 快排果然快！🤣</p><hr><blockquote><p> <a href="https://github.com/rensss/Sort">DEMO</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>上传自己的轮子-CocoaPods(续)</title>
      <link href="/2017/10/10/%E4%B8%8A%E4%BC%A0%E8%87%AA%E5%B7%B1%E7%9A%84%E8%BD%AE%E5%AD%90-CocoaPods-%E7%BB%AD/"/>
      <url>/2017/10/10/%E4%B8%8A%E4%BC%A0%E8%87%AA%E5%B7%B1%E7%9A%84%E8%BD%AE%E5%AD%90-CocoaPods-%E7%BB%AD/</url>
      
        <content type="html"><![CDATA[<p>上次我们上传了自己的轮子,这次我们就更新提交一下 这个轮子!</p><span id="more"></span><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol><li>更新代码到github</li><li>修改.podspec文件</li><li>上传到CocoaPods</li></ol><h3 id="详细"><a href="#详细" class="headerlink" title="详细"></a>详细</h3><ol><li><h4 id="更新代码"><a href="#更新代码" class="headerlink" title="更新代码"></a>更新代码</h4><ol><li><h5 id="上传代码"><a href="#上传代码" class="headerlink" title="上传代码"></a>上传代码</h5><pre><code>git add *git commit -m &quot;update tag 0.0.2&quot;git push origin -u master</code></pre><p>   <img src="http://upload-images.jianshu.io/upload_images/847229-3cd2e55001af4f40.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="git add.png"></p></li><li><h5 id="打tag"><a href="#打tag" class="headerlink" title="打tag"></a>打tag</h5><pre><code>git tag 0.0.2git push --tags</code></pre><p>​<img src="http://upload-images.jianshu.io/upload_images/847229-d0ca8e36cce4f858.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="git tag.png"></p></li></ol></li><li><h4 id="修改-podspec文件"><a href="#修改-podspec文件" class="headerlink" title="修改.podspec文件"></a>修改.podspec文件</h4><p>修改关键数据<code>s.version</code>和<code>s.source</code></p><pre><code>s.version = &quot;0.0.2&quot;s.source = &#123; :git =&gt; &quot;https://github.com/rensss/R_category.git&quot;, :tag =&gt; &quot;0.0.2&quot; &#125;</code></pre></li><li><h4 id="上传"><a href="#上传" class="headerlink" title="上传"></a>上传</h4><pre><code>pod trunk push R_category.podspec --allow-warnings</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/847229-60e63fb924e1fb17.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="pod trunk push.png"></p></li></ol><h3 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h3><p>搞定收工</p><blockquote><p>上篇<a href="https://rensss.github.io/2017/09/27/%E4%B8%8A%E4%BC%A0%E8%87%AA%E5%B7%B1%E7%9A%84%E8%BD%AE%E5%AD%90-CocoaPods/">上传自己的轮子_CocoaPods</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mac </tag>
            
            <tag> CocoaPods </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>上传自己的轮子_CocoaPods</title>
      <link href="/2017/09/27/%E4%B8%8A%E4%BC%A0%E8%87%AA%E5%B7%B1%E7%9A%84%E8%BD%AE%E5%AD%90-CocoaPods/"/>
      <url>/2017/09/27/%E4%B8%8A%E4%BC%A0%E8%87%AA%E5%B7%B1%E7%9A%84%E8%BD%AE%E5%AD%90-CocoaPods/</url>
      
        <content type="html"><![CDATA[<p>自己造轮子,上传到CocoaPods</p><span id="more"></span><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol><li>造轮子(创建自己的项目) , github 新建 repository , clone 到本地(我的<a href="https://rensss.github.io/R_category/">轮子</a>)</li><li>注册trunk,验证</li><li>创建.podspec文件 , 编辑 , 验证</li><li>发布trunk</li></ol><h3 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h3><ol><li><h4 id="造轮子-github-新建项目-网上教程很多-这里就不再赘述了"><a href="#造轮子-github-新建项目-网上教程很多-这里就不再赘述了" class="headerlink" title="造轮子 github 新建项目(网上教程很多,这里就不再赘述了)"></a>造轮子 github 新建项目(网上教程很多,这里就不再赘述了)</h4></li><li><h5 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h5><p><img src="http://upload-images.jianshu.io/upload_images/847229-d7e8cf0b245fcb08.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="创建新的项目.png"></p></li><li><h5 id="clone"><a href="#clone" class="headerlink" title="clone"></a>clone</h5><pre><code>git clone #本地目录</code></pre></li><li><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><pre><code>cd #进入工程文件 git add . git commit -m &#39;0.0.1&#39; git push origin master git tag 0.0.1 git push —tag</code></pre></li><li><h4 id="注册trunk"><a href="#注册trunk" class="headerlink" title="注册trunk"></a>注册trunk</h4><ul><li>注册 <code>pod trunk register renzzz@qq.com v587 —verbose</code></li><li>去邮箱复制链接到浏览器访问,就ok了</li><li>验证下<code>pod trunk me</code><br><img src="http://upload-images.jianshu.io/upload_images/847229-33861a5b115e7054.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="pod trunk me.png"><blockquote><p><strong>ps:</strong><br>​Pods:下是已发布的轮子</p></blockquote></li></ul></li><li><h4 id="创建-podspec文件-编辑-验证"><a href="#创建-podspec文件-编辑-验证" class="headerlink" title="创建.podspec文件 , 编辑 , 验证"></a>创建.podspec文件 , 编辑 , 验证</h4><ol><li><h5 id="初始化pod-spec-create-项目名字"><a href="#初始化pod-spec-create-项目名字" class="headerlink" title="初始化pod spec create #项目名字"></a>初始化<code>pod spec create #项目名字</code></h5></li><li><h5 id="编辑-podspec文件"><a href="#编辑-podspec文件" class="headerlink" title="编辑.podspec文件"></a>编辑.podspec文件</h5><pre><code>##  Be sure to run &#39;pod spec lint R_category.podspec&#39; to ensure this #  is a valid spec and to remove all comments including this before #  submitting the spec.#  To learn more about Podspec attributes see #  http://docs.cocoapods.org/specification.html#  To see working Podspecs in the CocoaPods repo see#  https://github.com/CocoaPods/Specs/##  一定要运行 &#39;pod spec lint xx.podspec&#39;来确保.podspec文件是有效的。#  并且最后在提交.podspec之前要移除所有注释.#  可以了解更过关于Podspec，通过http://docs.cocoapods.org/specification.html#  see https://github.com/CocoaPods/Specs/Pod::Spec.new do |s|# ―――――――――――――――――  Spec Metadata ――――――――――――――――――――― ###  These will help people to find your library, and whilst it#  can feel like a chore to fill in it&#39;s definitely to your advantage.#  The#  summary should be tweet-length, and the description more in depth.# # ―――――――――――――――――  Spec 元数据  ――――――――――――――――――――――― ###  这些将帮助人们找到你的库，同时在成为你的优势之前可能感觉是麻烦的。#  概要的长度限制与推特的一样（140），并且这个描述更加深入#  s.summary最好不要与s.description一样，会报警告(多写两字不会死)  s.name         = &quot;R_category&quot;  s.version      = &quot;0.0.1&quot;  s.summary      = &quot;A short description of R_category.&quot;#  This description is used to generate tags and improve search #  results.#  * Think: What does it do? Why did you write it? What is the focus?#  * Try to keep it short, snappy and to the point.#  * Write the description between the DESC delimiters below.#  * Finally, don&#39;t worry about the indent, CocoaPods strips it!  #  这个描述用来生成标签和改善搜索结果#  思考:它做了什么？你为什么要写它？重点是什么？#  尽力保持它简短，精炼#  在DESC之间写这个描述#  最后不要担心缩进。cocoapods将做它。    s.description  = &lt;&lt;-DESC             zheshiyigejiandandemiaoshu(这是一个简单的描述)                      DESC               #  主页地址，直接填写我们的仓库地址即可  s.homepage     = &quot;http://EXAMPLE/R_category&quot;#  屏幕截图(不需要关心，直接删除即可)#  s.screenshots  = &quot;www.example.com/screenshots_1.gif&quot;, #  &quot;www.example.com/screenshots_2.gif&quot;# ――――――――――――――――――  Spec License  ―――――――――――――――――――― ###  Licensing your code is important. See http://choosealicense.com for #  more info.#  CocoaPods will detect a license file if there is a named LICENSE*#  Popular ones are &#39;MIT&#39;, &#39;BSD&#39; and &#39;Apache License, Version 2.0&#39;.## ―――――――――――――――――――  Spec 授权  ――――――――――――――――――――――― ###  授权你的代码是很重要的。查看http://choosealicense.com得到更多的信息#  CocoaPods 如果这里有一个命名为LICENSE*的文件，那么Cocoapods将检测这个授权文件#  主要的授权为:&#39;MIT&#39;, &#39;BSD&#39; and &#39;Apache License, Version 2.0&#39;  s.license      = &quot;MIT&quot;#  s.license      = &#123; :type =&gt; &quot;MIT&quot;, :file =&gt; &quot;FILE_LICENSE&quot; &#125;# ――――――――――――――――― Author Metadata ――――――――――――――――――― ###  Specify the authors of the library, with email addresses. Email #  addresses#  of the authors are extracted from the SCM log. E.g. $ git log.#  CocoaPods also#  accepts just a name if you&#39;d rather not provide an email address.##  Specify a social_media_url where others can refer to, for example a #  twitter#  profile URL.  # ――――――――――――――――― 作者 元数据  ―――――――――――――――――――――――― ###  指定这个库的作者和email地址。#  作者的email地址也可以通过 $ git log来提取。#  如果你不愿意提供邮箱，CocoaPods也接受仅仅一个名字#  指定一个别人可以访问的社交账号，例如推特#  s.social_media_url这一项最好不要指定了，因为推特国内无法访问，验证.podsec时，#  不通过。#  填写用户名以及自己的github邮箱  s.author             = &#123; &quot;lhjzzu&quot; =&gt; &quot;1822657131@qq.com&quot; &#125;#  Or just: s.author    = &quot;lhjzzu&quot;#  s.authors            = &#123; &quot;lhjzzu&quot; =&gt; &quot;1822657131@qq.com&quot; &#125;#  s.social_media_url   = &quot;http://twitter.com/lhjzzu&quot;# ――――――――――――――――――― Platform Specifics ――――――――――――――― ###  If this Pod runs only on iOS or OS X, then specify the platform and#  the deployment target. You can optionally include the target after #  the platform.  # ――――――――――――――――――― 平台的指定 ―――――――――――――――――――――― ###  如果你的Pod仅仅运行在iOS或者OS X上，那么要指定platform以及deployment #  target。#  一般而言，我们直选择#  s.platform = :ios和s.ios.deployment_target = &quot;5.0&quot;#  s.platform     = :ios, &quot;5.0&quot;与上面两句话相等#  s.platform     = :ios  s.platform     = :ios, &quot;5.0&quot;#  When using multiple platforms#  s.ios.deployment_target = &quot;5.0&quot;#  s.osx.deployment_target = &quot;10.7&quot;#  s.watchos.deployment_target = &quot;2.0&quot;#  s.tvos.deployment_target = &quot;9.0&quot;# ――――――――――――――――― Source Location ―――――――――――――――――――― ###  Specify the location from where the source should be retrieved.#  Supports git, hg, bzr, svn and HTTP.#  # ――――――――――――――――――― 资源的位置 ――――――――――――――――――――――――― ###  指定将被拉取的资源的位置#  支持 git, hg, bzr, svn and HTTP.#  http://EXAMPLE/R_category.git 就是我们仓库的地址(一定不要忘了.git)#  tag =&gt; &quot;0.0.1&quot; 就是我们打的标签    s.source       = &#123; :git =&gt; &quot;http://EXAMPLE/R_category.git&quot;, :tag =&gt; &quot;0.0.1&quot; &#125;# ――――――――――――――――― Source Code ――――――――――――――――――――――― ###  CocoaPods is smart about how it includes source code. For source #  files#  giving a folder will include any swift, h, m, mm, c &amp; cpp files.#  For header files it will include any header in the folder.#  Not including the public_header_files will make all headers public.#  # ――――――――――――――――――― 源码 ――――――――――――――――――――――――――――― ###  对于怎样去包含源码，cocoapods是很聪明的。#  s.source_files将包含所有的源文件（swift, h, m, mm, c &amp; cpp）#  s.exclude_files要排除的文件（一般直接删除即可）#  s.public_header_files 指定我们想公开的头文件#  如果不含有s.public_header_files，那么我们的.h文件是默认全部公开的。  s.source_files  = &quot;R_category&quot;, &quot;R_category/**/*.&#123;h,m&#125;&quot;#  s.exclude_files = &quot;Classes/Exclude&quot;#  s.public_header_files = &quot;Classes/**/*.h&quot;# ――――――――――――――――――― Resources ――――――――――――――――――――――― ###  A list of resources included with the Pod. These are copied into the#  target bundle with a build phase script. Anything else will be #  cleaned.#  You can preserve files from being cleaned, please don&#39;t preserve#  non-essential files like tests, examples and documentation.## ――――――――――――――――――― 资源 ―――――――――――――――――――――――――――― ###  这个Pod包含的一系列的资源。在编译脚本的阶段，它们被复制到这个目标bundle中。#  其它的任何资源将被清理。你可以保护文件免于被清理，但是请不要保存不必要的文件#  例如tests，examples，documentation#  s.resource  = &quot;icon.png&quot;#  s.resources = &quot;Resources/*.png&quot;#  s.preserve_paths = &quot;FilesToSave&quot;, &quot;MoreFilesToSave&quot;# ―――――――――――――――――― Project Linking ――――――――――――――――――――###  Link your library with frameworks, or libraries. Libraries do not #  include#  the lib prefix of their name.  # ――――――――――――――――――― 项目 链接 ―――――――――――――――――――――――――― ###  链接你的Framework和library（系统的Framework，library）. #  librarys的指定不包含lib的前缀，例如libxml2.tbd  #  s.framework  = &quot;SomeFramework&quot;#  s.frameworks = &quot;SomeFramework&quot;, &quot;AnotherFramework&quot;#  s.library   = &quot;iconv&quot;#  s.libraries = &quot;iconv&quot;, &quot;xml2&quot; # ――――――――――――――――――― Project Settings ――――――――――――――――― ###  If your library depends on compiler flags you can set them in the #  xcconfig hash#  where they will only apply to your library. If you depend on other #  Podspecs#  you can include multiple dependencies to ensure it works.# ――――――――――――――――――― 项目 设置 ――――――――――――――――――――――――― ##  如果你的library依赖一个compiler flags。你能设置他们在xcconfig，它们将应用于你#  的lib中。#  如果你的pods依赖其他的Podspecs，你能够包含多个依赖来确保它工作。#  s.requires_arc指定是否为ARC#  s.xcconfig做一些配置#  s.dependency指定依赖  #  s.requires_arc = true#  s.xcconfig = &#123; &quot;HEADER_SEARCH_PATHS&quot; =&gt; &quot;$(SDKROOT)/usr/include/libxml2&quot; &#125;#  s.dependency &quot;JSONKit&quot;, &quot;~&gt; 1.4&quot;end</code></pre></li><li><h5 id="最终的-podspec文件"><a href="#最终的-podspec文件" class="headerlink" title="最终的.podspec文件"></a>最终的.podspec文件</h5><p>```<br>Pod::Spec.new do |s|<br>s.name         = “R_category”<br>s.version      = “0.0.1”<br>s.summary      = “一个简单的分类扩展.”<br>s.description  = &lt;&lt;-DESC</p><pre><code>      a simple demo              DESC</code></pre><p>s.homepage     = “<a href="https://github.com/rensss/R_category&quot;">https://github.com/rensss/R_category&quot;</a><br>s.license      = ‘MIT’<br>s.author       = { “v587” =&gt; “<a href="mailto:&#x72;&#101;&#110;&#122;&#122;&#x7a;&#64;&#x71;&#x71;&#x2e;&#x63;&#x6f;&#x6d;">&#x72;&#101;&#110;&#122;&#122;&#x7a;&#64;&#x71;&#x71;&#x2e;&#x63;&#x6f;&#x6d;</a>“ }<br>s.platform     = :ios<br>s.ios.deployment_target = “5.0”</p></li></ol><p> s.source       = { :git =&gt; “<a href="https://github.com/rensss/R_category.git&quot;">https://github.com/rensss/R_category.git&quot;</a>, :tag =&gt; “0.0.1” }</p><p> s.source_files  = “category_Class”, “category_Class/*.{h,m}”</p><h1 id="s-exclude-files-“Classes-Exclude”"><a href="#s-exclude-files-“Classes-Exclude”" class="headerlink" title="s.exclude_files = “Classes/Exclude”"></a>s.exclude_files = “Classes/Exclude”</h1><h1 id="s-public-header-files-“Classes-h”"><a href="#s-public-header-files-“Classes-h”" class="headerlink" title="s.public_header_files = “Classes/**/*.h”"></a>s.public_header_files = “Classes/**/*.h”</h1><p> s.requires_arc = true</p><h1 id="s-xcconfig-“HEADER-SEARCH-PATHS”-gt-“-SDKROOT-usr-include-libxml2”"><a href="#s-xcconfig-“HEADER-SEARCH-PATHS”-gt-“-SDKROOT-usr-include-libxml2”" class="headerlink" title="s.xcconfig = { “HEADER_SEARCH_PATHS” =&gt; “$(SDKROOT)/usr/include/libxml2” }"></a>s.xcconfig = { “HEADER_SEARCH_PATHS” =&gt; “$(SDKROOT)/usr/include/libxml2” }</h1><h1 id="s-dependency-“JSONKit”-“-gt-1-4”"><a href="#s-dependency-“JSONKit”-“-gt-1-4”" class="headerlink" title="s.dependency “JSONKit”, “~&gt; 1.4”"></a>s.dependency “JSONKit”, “~&gt; 1.4”</h1><p>end</p><pre><code>4. ##### 验证.podspec文件</code></pre><p>pod spec lint R_category.podspec –verbose<br>如果出现下面的信息，表示验证通过<br>R_category.podspec passed validation.<br>```</p><blockquote><p><strong>ps:</strong><br><code>--vebose</code>:打印细节，可以把执行过程中具体的信息打印出来<br><img src="http://upload-images.jianshu.io/upload_images/847229-005e8ae9de7a6ea0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="pod spec lint.png"><br><code>--allow-warnings</code> 表示忽略警告 当有警告不通过时 添加此参数</p></blockquote></li><li><h4 id="发布trunk"><a href="#发布trunk" class="headerlink" title="发布trunk"></a>发布trunk</h4><ol><li><h5 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h5>```<br>pod trunk push R_category.podspec –verbose<br>如果有下面的信息显示，表明push成功</li></ol><ul><li>Data URL: xxxxxxxx</li><li>Log messages:</li><li>May 9th, 23:29: Push for ‘R_category 0.0.1’ initiated.</li><li>May 9th, 23:29: Push for ‘R_category 0.0.1’ has been pushed  (3.41790716 s).<br>```</li></ul><ol start="2"><li><h5 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h5><pre><code>pod search R_category</code></pre><blockquote><p><strong>ps:</strong><br>​最好停一段时间再搜索<br>​请先更新本地pod库 <code>pod setup</code> 或者 <code>Pod repo update</code><br>​如果还是搜索不到,请删除search_index.json文件.在这个目录下<br><code>/Users/&lt;你的用户名&gt;/Library/Caches/CocoaPods/</code><br><img src="http://upload-images.jianshu.io/upload_images/847229-d80d586cdbdd833a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/840" alt="search_index_json.png"></p></blockquote></li></ol></li></ol><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>   报错时请不要慌张,不要放弃,你终将成功的!</p><blockquote><p>下篇<a href="https://rensss.github.io/2017/10/10/%E4%B8%8A%E4%BC%A0%E8%87%AA%E5%B7%B1%E7%9A%84%E8%BD%AE%E5%AD%90-CocoaPods-%E7%BB%AD/">上传自己的轮子-CocoaPods(续)</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mac </tag>
            
            <tag> CocoaPods </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用PM2让hexo始终运行</title>
      <link href="/2017/08/09/%E4%BD%BF%E7%94%A8PM2%E8%AE%A9hexo%E5%A7%8B%E7%BB%88%E8%BF%90%E8%A1%8C/"/>
      <url>/2017/08/09/%E4%BD%BF%E7%94%A8PM2%E8%AE%A9hexo%E5%A7%8B%E7%BB%88%E8%BF%90%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>在Mac下,编辑hexo以后每次都要 <code>hexo g</code> <code>hexo s</code> , 还要一直开着终端,特别烦人!<span id="more"></span><br>寻思着怎么让hexo一直后台运行,然后在网上找到了这个神器 <strong>pm2</strong><br><img src="https://i.loli.net/2021/06/29/cW3v8UgedBTuRQs.png" alt="pm2.png"></p><blockquote><p><em>PM2.JPG</em></p></blockquote><h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><p>1.安装pm2</p><pre><code>npm install -g pm2</code></pre><p>2.编辑脚本代码<br>    在hexo博客的根目录下新建<code>app.js</code>文件<br>    编写内容</p><pre><code>//run.jsconst &#123; exec &#125; = require(&#39;child_process&#39;)exec(&#39;hexo s&#39;,(error, stdout, stderr) =&gt; &#123;    if(error)&#123;         console.log(`exec error: $&#123;error&#125;`)         return    &#125;    console.log(`stdout: $&#123;stdout&#125;`);    console.log(`stderr: $&#123;stderr&#125;`);&#125;)</code></pre><h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><p>1.运行</p><pre><code>pm2 start app.js</code></pre><p>2.常用命令</p><pre><code>pm2 start app.js -i 4           # 后台运行pm2，启动4个app.js                                 # 也可以把&#39;max&#39; 参数传递给 start                                # 正确的进程数目依赖于Cpu的核心数目pm2 start app.js --name my-api  # 命名进程pm2 list                        # 显示所有进程状态pm2 monit                       # 监视所有进程pm2 logs                        # 显示所有进程日志pm2 stop all                    # 停止所有进程pm2 restart all                 # 重启所有进程pm2 reload all                  # 0秒停机重载进程 (用于 NETWORKED 进程)pm2 stop 0                      # 停止指定的进程pm2 restart 0                   # 重启指定的进程pm2 startup                     # 产生 init 脚本 保持进程活着pm2 web                         # 运行健壮的 computer API endpoint                                # (http://localhost:9615)pm2 delete 0                    # 杀死指定的进程pm2 delete all                  # 杀死全部进程</code></pre><p><img src="https://i.loli.net/2021/06/29/1XWVGptqxOaB9cM.png" alt="pm2 list-2017-08-09-下午12.06.06.png"></p><blockquote><p><em>pm2 list</em></p></blockquote><h4 id="OVER"><a href="#OVER" class="headerlink" title="OVER"></a>OVER</h4>]]></content>
      
      
      <categories>
          
          <category> PM2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mac </tag>
            
            <tag> Hexo </tag>
            
            <tag> PM2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>添加简书图片测试</title>
      <link href="/2017/08/09/%E6%B7%BB%E5%8A%A0%E7%AE%80%E4%B9%A6%E5%9B%BE%E7%89%87%E6%B5%8B%E8%AF%95/"/>
      <url>/2017/08/09/%E6%B7%BB%E5%8A%A0%E7%AE%80%E4%B9%A6%E5%9B%BE%E7%89%87%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h5 id="添加图片"><a href="#添加图片" class="headerlink" title="添加图片"></a>添加图片</h5><p>试试简书的图片链接<span id="more"></span><br><img src="http://upload-images.jianshu.io/upload_images/847229-ad4cf2d90ecc8d33.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="MN.jpg"></p><blockquote><p><em>MN.jpg</em></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 杂类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图片 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac + Hexo + GitHub 创建个人博客</title>
      <link href="/2017/06/25/Mac-hexo-github-%E5%88%9B%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2017/06/25/Mac-hexo-github-%E5%88%9B%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>之前浏览过很多人的博客,感觉十分酷炫.</p><span id="more"></span><p>之后就搜集很多搭建的资料(其实就是别人发的博客),存到印象笔记里去.然而过了很久一直畏难没有实施😂.<br>某日心血来潮忽然特别想搞出来,就跟着别人的脚步,一个坑一个坑的踩过来了.</p><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>1.Ruby<br>2.Node<br>3.Hexo<br>4.GitHub帐号</p><h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p>1.<br>Mac系统自带Ruby,so忽略</p><p>2.<br>Node<br>用homebrew安装</p><pre><code>brew install node</code></pre><p>3.<br>Hexo<br>可以使用nodejs自带的 npm 进行安装.</p><pre><code>npm install -g hexo</code></pre><p>4.<br>GitHub<br>4.1<br>申请GitHub帐号<br>4.2<br>在自己的GitHub主页右上角,创建一个新的repository.我的GitHub账号是<code>rensss</code>,<br>那么我创建的repository名字就应该为<code>rensss.github.io</code></p><h3 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h3><h4 id="初始化hexo"><a href="#初始化hexo" class="headerlink" title="初始化hexo"></a>初始化hexo</h4><p>1.<br>在Mac上找一个地方新建一个文件夹存放你的站点.例如我在<code>/Users/&lt;UserName&gt;/Documents</code>下新建的文件夹hexo.具体路径是 <code>/Users/&lt;UserName&gt;/Documents/hexo</code><br>2.<br>初始化hexo</p><pre><code>cd /Users/&lt;UserName&gt;/Documents/hexohexo init       #初始化npm install     #npm初始化 </code></pre><p>3.<br>本地预览</p><pre><code>hexo clean      #清理缓存hexo generate   #编译hexo server     #开启服务</code></pre><p>之后,本地访问<code>0.0.0.0:4000</code>就可以看到hexo的欢迎界面了✌️</p><h4 id="上传git"><a href="#上传git" class="headerlink" title="上传git"></a>上传git</h4><p>1.<br>改写<code>_config.yml</code>文件末尾的<code>deploy:</code>标签</p><pre><code>type: git  repository: https://github.com/rensss/rensss.github.io.git  branch: master</code></pre><p>2.<br>安装<code>hexo-deployer-git</code> git上传用</p><pre><code>npm install hexo-deployer-git --save</code></pre><p>3.<br>先编译再上传</p><pre><code>hexo ghexo deploy</code></pre><p>如果无报错,之后等一段时间,就可以访问你的博客了!<br>ps:这段时间可能非常长!!!</p><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>中间踩坑不断,欲哭无泪,各种谷歌/百度.<br>At the end. 我终于搞出来了!</p><blockquote><p>ps:可能遇到的问题</p><ol><li>hexo 安装失败<br>npm WARN checkPermissions Missing write access to /usr/local/lib/node_modules<br>npm ERR! code EACCES<br>npm ERR! syscall access<br>npm ERR! path /usr/local/lib/node_modules<br>npm ERR! errno -13<br><img src="https://i.loli.net/2020/12/30/sSreygUFGJDtxdQ.png" alt="npm install -g hexo.png"><br>解决方案： 修改权限</li></ol><pre><code>sudo chown -R $USER /usr/local/lib/node_modules</code></pre></blockquote>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GitHub </tag>
            
            <tag> Mac </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过添加手势的方法处理CALayer的点击事件</title>
      <link href="/2016/02/04/%E9%80%9A%E8%BF%87%E6%B7%BB%E5%8A%A0%E6%89%8B%E5%8A%BF%E7%9A%84%E6%96%B9%E6%B3%95%E5%A4%84%E7%90%86CALayer%E7%9A%84%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6/"/>
      <url>/2016/02/04/%E9%80%9A%E8%BF%87%E6%B7%BB%E5%8A%A0%E6%89%8B%E5%8A%BF%E7%9A%84%E6%96%B9%E6%B3%95%E5%A4%84%E7%90%86CALayer%E7%9A%84%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>当给UIView添加Animation动画时，项目需要添加点击事件。<span id="more"></span><br>但是使用UIButton无效，不响应点击事件。<br>baidu / google 之。<br>发现UILayer不响应事件。<br>换一种思路，发现可以给整个视图添加点击手势，然后判断点击位置来触发事件。</p><h5 id="代码片段"><a href="#代码片段" class="headerlink" title="代码片段"></a>代码片段</h5><pre><code>    //创建手势添加到视图上    self.tapGesture = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(click:)];    [self.view addGestureRecognizer:self.tapGesture];      #pragma mark - 点击        /** 点击事件*/    -(void)click:(UITapGestureRecognizer *)tapGesture &#123;            CGPoint touchPoint = [tapGesture locationInView:self];        //遍历当前视图上的子视图的presentationLayer 与点击的点是否有交集        for (UIView *subView in self.view.subviews) &#123;            if ([subView.layer.presentationLayer hitTest:touchPoint]) &#123;                NSLog(@&quot;点击的是：%@&quot;,subView);            &#125;        &#125;    &#125;</code></pre><h5 id="打完收工"><a href="#打完收工" class="headerlink" title="打完收工"></a>打完收工</h5>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CALayer </tag>
            
            <tag> UITapGestureRecognizer </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
